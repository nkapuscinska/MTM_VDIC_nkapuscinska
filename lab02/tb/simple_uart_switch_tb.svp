module top;

localparam int unsigned CLKS_PER_BIT = 16;


typedef enum bit {
    TEST_PASSED,
    TEST_FAILED
} test_result_t;

typedef struct packed {
    bit        start_bit;
    bit        [7:0]  data_bits;
    bit        parity_bit;
    bit        stop_bit;

} uart_frame_t;


typedef struct {
    uart_frame_t    adres_frame;
    uart_frame_t    data_frame;
} uart_packet_t;

typedef struct {
    bit [7:0] address;
    bit [7:0] data;
    bit port;
} uart_observed_t;

bit [7:0] addr;
bit [7:0] data;
bit [7:0] port;
bit [7:0] addr_cov;
bit [7:0] data_cov;
bit [7:0] port_cov;
bit [7:0] rst_n_cov;
bit [7:0] op_address_sent;  
bit       op_port_sent;  


typedef enum {
    COLOR_BOLD_BLACK_ON_GREEN,
    COLOR_BOLD_BLACK_ON_RED,                   
    COLOR_BOLD_BLACK_ON_YELLOW,
    COLOR_BOLD_BLUE_ON_WHITE,
    COLOR_BLUE_ON_WHITE,
    COLOR_DEFAULT
} print_color_t;


uart_packet_t packet_q[$];
uart_packet_t coverage_packet_q[$];
uart_observed_t expected_data_q[$];
uart_observed_t observed_q[$];



typedef bit [7:0] addr_t;
typedef bit [7:0] port_t;

port_t temp;
addr_t key;

port_t address_map [bit [7:0]];
//------------------------------------------------------------------------------
// Local variables
//------------------------------------------------------------------------------

bit                  clk;
bit                  rst_n;
bit                  prog;
bit                  sin;
bit                 sout0;
bit                 sout1;

test_result_t        test_result = TEST_PASSED;


//------------------------------------------------------------------------------
// DUT instantiation
//------------------------------------------------------------------------------

simple_switch_uart DUT (

    .clk, 
    .rst_n, 
    .prog, 
    .sin, 
    .sout0, 
    .sout1
    );


//------------------------------------------------------------------------------
// Clock generator
//------------------------------------------------------------------------------

initial begin : clk_gen_blk
    clk = 0;
    forever begin : clk_frv_blk
        #10;
        clk = ~clk;
    end
end

initial begin
    prog = 1;
end


     
//------------------------------------------------------------------------------
// Other functions
//------------------------------------------------------------------------------

// used to modify the color of the text printed on the terminal
function void set_print_color ( print_color_t c );
    string ctl;
    case(c)
        COLOR_BOLD_BLACK_ON_GREEN : ctl  = "\033\[1;30m\033\[102m";
        COLOR_BOLD_BLACK_ON_RED : ctl    = "\033\[1;30m\033\[101m";
        COLOR_BOLD_BLACK_ON_YELLOW : ctl = "\033\[1;30m\033\[103m";
        COLOR_BOLD_BLUE_ON_WHITE : ctl   = "\033\[1;34m\033\[107m";
        COLOR_BLUE_ON_WHITE : ctl        = "\033\[0;34m\033\[107m";
        COLOR_DEFAULT : ctl              = "\033\[0m\n";
        default : begin
            $error("set_print_color: bad argument");
            ctl                          = "";
        end
    endcase
    $write(ctl);
endfunction


function uart_frame_t create_uart_frame(bit [7:0] data);
    uart_frame_t frame;

    frame.start_bit = 0;
    frame.data_bits = data;
    frame.parity_bit = ^data;
    frame.stop_bit = 1;

    return frame;
endfunction

function uart_packet_t create_functional_packet(bit [7:0] address);
    uart_packet_t packet;
    bit [7:0] data;

    data = $urandom_range(0, 255);
    

    packet.adres_frame = create_uart_frame(address);
    packet.data_frame  = create_uart_frame(data);
    return packet;
endfunction


function uart_packet_t create_uart_packet(bit [7:0] address);
    uart_packet_t packet;
    bit [7:0] port;

    port = $urandom_range(0, 1);

    packet.adres_frame = create_uart_frame(address);
    packet.data_frame  = create_uart_frame(port);

    return packet;
endfunction

task automatic send_uart_frame(
    input uart_frame_t frame, 
    ref bit sin,
    input bit force_parity_error = 0
);
    bit parity_bit_to_send;

    sin = frame.start_bit;
    repeat (CLKS_PER_BIT) @(posedge clk);

    for (int i = 0; i < 8; i++) begin
        sin = frame.data_bits[i];
        repeat (CLKS_PER_BIT) @(posedge clk);
    end

    if (force_parity_error)
        parity_bit_to_send = ~frame.parity_bit;
    else
        parity_bit_to_send = frame.parity_bit;

    sin = parity_bit_to_send;
    repeat (CLKS_PER_BIT) @(posedge clk);

    sin = frame.stop_bit;
    repeat (CLKS_PER_BIT) @(posedge clk);
endtask



task automatic send_uart_packet(input uart_packet_t packet, ref bit sin);
    addr_cov = packet.adres_frame.data_bits;
    data_cov = packet.data_frame.data_bits;
    port_cov = packet.data_frame.data_bits;
    send_uart_frame(packet.adres_frame, sin);
    send_uart_frame(packet.data_frame, sin);
endtask

task automatic send_config_packets();

    $display("Starting to send packets...");

    while (packet_q.size() > 0) begin
        uart_packet_t pkt;
        pkt = packet_q.pop_front();
        send_uart_packet(pkt, sin);
    end

    $display("Queue is empty.");
endtask

task automatic generate_config_packets();
    uart_packet_t pkt;
    for (int i = 0; i < 256; i++) begin
        pkt = create_uart_packet(i);
        packet_q.push_back(pkt);
        address_map[i] = pkt.data_frame.data_bits;
    end
endtask

task automatic monitor_clock();
    static longint clk_counter = 0;
    forever begin
        @(posedge clk) clk_counter++;
        if (clk_counter % 1000 == 0) begin
            $display("%0t Clock cycles elapsed: %0d", $time, clk_counter);
        end
    end
endtask

task automatic send_functional_packets();
    uart_observed_t exp;
    uart_packet_t pkt;

    $display("Switched to functional mode. Sending functional packets...");

    for (int i = 0; i < 256; i++) begin
        pkt = create_functional_packet(i);
        send_uart_packet(pkt, sin);
        exp.address = i;
        exp.data    = pkt.data_frame.data_bits;
        exp.port    = address_map[i];
        expected_data_q.push_back(exp);


        $display("Sent packet: addr=%0d data=0x%0h expected_port=%0d",
                 exp.address, exp.data, exp.port);
    end
endtask



task automatic monitor();
    uart_observed_t obs;
    static bit [7:0] shift_reg = 0;
    static bit [3:0] bit_index = 0;
    static bit frame_phase = 0; // 0 = address frame, 1 = data frame
    static bit [7:0] received_address;
    static bit current_port;
    static bit [7:0] received_data;
    static bit prev_sout0 = 1;
    static bit prev_sout1 = 1;

    forever begin
        @(posedge clk);

        if ((prev_sout0 == 1 && sout0 == 0) || (prev_sout1 == 1 && sout1 == 0)) begin
            current_port = (sout1 == 0);
            shift_reg = 0;

            for (bit_index = 0; bit_index < 8; bit_index++) begin
                repeat (CLKS_PER_BIT) @(posedge clk);
                shift_reg[bit_index] = (current_port == 1) ? sout1 : sout0;
            end

            repeat (CLKS_PER_BIT * 2) @(posedge clk);

            if (frame_phase == 0) begin
                received_address = shift_reg;
                frame_phase = 1;
            end else begin
                received_data = shift_reg;
                frame_phase = 0;

                obs.address = received_address;
                obs.data    = received_data;
                obs.port    = current_port;
                observed_q.push_back(obs);

                $display("Received packet: addr=%0d data=0x%0h actual_port=%0d",
                         obs.address, obs.data, obs.port);
            end
        end

        prev_sout0 = sout0;
        prev_sout1 = sout1;
    end
endtask

task automatic scoreboard();
    int errors = 0;
    $display("Verifying data integrity... expected %0d frames", expected_data_q.size());

    for (int i = 0; i < expected_data_q.size(); i++) begin
        uart_observed_t exp = expected_data_q[i];
        uart_observed_t obs;

        bit found = 0;
        for (int j = 0; j < observed_q.size(); j++) begin
            obs = observed_q[j];
            if (obs.address === exp.address) begin
                found = 1;

                if (obs.data === exp.data && obs.port === exp.port) begin
                    set_print_color(COLOR_BOLD_BLACK_ON_GREEN);
                    $display("Address %0d → PASS (expected port %0d, actual port %0d, data=0x%0h)",
                             exp.address, exp.port, obs.port, obs.data);
                end else begin
                    set_print_color(COLOR_BOLD_BLACK_ON_RED);
                    $display("Address %0d → FAIL (expected port %0d, actual port %0d, expected data=0x%0h, actual data=0x%0h)",
                             exp.address, exp.port, obs.port, exp.data, obs.data);
                    errors++;
                end
                set_print_color(COLOR_DEFAULT);
                break;
            end
        end

        if (!found) begin
            set_print_color(COLOR_BOLD_BLACK_ON_RED);
            $display("Address %0d → FAIL (frame not received!)", exp.address);
            set_print_color(COLOR_DEFAULT);
            errors++;
        end
    end

    if (errors == 0) begin
        set_print_color(COLOR_BOLD_BLACK_ON_GREEN);
        $display("DATA INTEGRITY TEST: PASS");
    end else begin
        set_print_color(COLOR_BOLD_BLACK_ON_RED);
        $display("DATA INTEGRITY TEST: FAIL (%0d errors)", errors);
    end
    set_print_color(COLOR_DEFAULT);
endtask

task automatic send_uart_frame_with_bad_parity(input uart_frame_t frame);
    send_uart_frame(frame, sin, 1);
endtask

task automatic test_bad_parity();
    uart_packet_t pkt;
    int obs_size_before;
    uart_observed_t obs;

    $display("=== Starting BAD PARITY test ===");

    for (int i = 0; i < 5; i++) begin
        bit [7:0] random_parity_addr;
        random_parity_addr = $urandom_range(0, 255);
        pkt = create_uart_packet(random_parity_addr);
        obs_size_before = observed_q.size();

        send_uart_frame_with_bad_parity(pkt.adres_frame);
        send_uart_frame_with_bad_parity(pkt.data_frame);

        # (CLKS_PER_BIT * 20); //waiting for dut 

        if (observed_q.size() > obs_size_before) begin
            set_print_color(COLOR_BOLD_BLACK_ON_RED);
            $display("FAIL: DUT forwarded frame with bad parity");
            set_print_color(COLOR_DEFAULT);
        end
        else begin
            set_print_color(COLOR_BOLD_BLACK_ON_GREEN);
            $display("PASS: DUT correctly ignored frame");
            set_print_color(COLOR_DEFAULT);
        end
    end
endtask

task automatic test_reset();
begin
    $display("=== Testing DUT reset ===");

    rst_n = 0;
    repeat (10) @(posedge clk); 
    rst_n = 1;
    repeat (5) @(posedge clk);        

    if (sout0 !== 1'b1 || sout1 !== 1'b1) begin
        set_print_color(COLOR_BOLD_BLACK_ON_RED);
        $display("RESET TEST → FAIL (sout0=%b, sout1=%b)", sout0, sout1);
        set_print_color(COLOR_DEFAULT);
        test_result = TEST_FAILED;
    end else begin
        set_print_color(COLOR_BOLD_BLACK_ON_GREEN);
        $display("RESET TEST → PASS (sout0=%b, sout1=%b)", sout0, sout1);
        set_print_color(COLOR_DEFAULT);
    end
end
endtask

//------------------------------------------------------------------------------
// Coverages
//------------------------------------------------------------------------------



// Covergroup checking the adressing
    covergroup op_adres;

        option.name = "cg_op_adres";

        coverpoint addr_cov {
            bins A1_all_addr[] = {[0:255]} iff (prog == 1);
        }

        coverpoint port_cov {
            bins A2_all_ports[] = {[0:1]} iff (prog == 1);
        }


    endgroup

    covergroup op_data;

        option.name = "cg_op_data";

        coverpoint data_cov {
            // #A1 test all adresses
            bins A1_all_data[]     = {[0:255]} iff (prog == 0);

        }

    endgroup

    // Covergroup checking the adressing
    covergroup op_options;

        option.name = "cg_op_options";

        coverpoint prog {
            // #A1 test if programing mode was tested
            bins A1_prog[]     = {[0:1]};
        }
        coverpoint rst_n {
            // #A2 test if rst_n was triggered
            bins A2_Reset_n[]      = {[0:1]};

        }

    endgroup

op_adres      adrr_cov;
op_data         dat_cov;
op_options      op_cov;

initial begin : coverage
    adrr_cov      = new();
    dat_cov      = new();
    op_cov      = new();

    forever begin : sample_cov
        @(posedge clk);
        adrr_cov.sample();
        dat_cov.sample();
        op_cov.sample();

    end
end : coverage

     
//------------------------------------------------------------------------------
// Simulation
//------------------------------------------------------------------------------

initial begin
    rst_n = 0;
    #100;
    rst_n = 1;
end


initial begin
    prog = 1;

    fork
        monitor_clock();
        monitor();

    join_none

    generate_config_packets();
    send_config_packets();
    prog = 0;
    send_functional_packets();
    #(CLKS_PER_BIT*12*256);
    scoreboard();

    test_bad_parity();
    repeat (6*CLKS_PER_BIT) @(posedge clk);
    test_reset();
    if (test_result == TEST_PASSED)
        $display("TEST RESULT: PASS");
    else
        $display("TEST RESULT: FAIL");

    $finish;
end


endmodule : top