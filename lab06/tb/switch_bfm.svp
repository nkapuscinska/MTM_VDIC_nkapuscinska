interface switch_bfm;
import fifomult_tb_pkg::*; 
   
logic clk;
logic rst_n;
logic prog;
bit sin;
logic sout0;
logic sout1;




// event ev_reset_test_start;
// event ev_bad_parity_test_start;
// event ev_end_of_test;

operation_t op_set;


command_monitor command_monitor_h;
result_monitor result_monitor_h; 

// uart_packet_t packet_q[$];
// uart_packet_t coverage_packet_q[$];
// uart_observed_t expected_data_q[$];
// uart_observed_t observed_q[$];


    initial begin : clk_gen_blk
        clk = 0;
        forever begin : clk_frv_blk
            #10;
            clk = ~clk;
        end
    end

    initial begin
                command_s cmd;
        bit [7:0] shift_reg;
        bit [3:0] bit_index;
        bit frame_phase = 0;
        bit [7:0] received_address, received_data;
        bit current_port;
        bit prev_sout0 = 1, prev_sout1 = 1;

        // pkt, który złożymy i wyślemy do scoreboardu
        uart_packet_t pkt;

        
        forever begin
            @(negedge bfm.sout0 or negedge bfm.sout1);

            // Odczyt bitów przychodzących
            $display("Monitor: Detected start bit on sout0=%0b, sout1=%0b", bfm.sout0, bfm.sout1);
            current_port = (bfm.sout1 == 0);
            shift_reg = 0;
            repeat(CLKS_PER_BIT/2) @(posedge bfm.clk);
            for (bit_index = 0; bit_index < 10; bit_index++) begin
                if (bit_index != 0 && bit_index != 9)
                    shift_reg[bit_index-1] = (current_port == 1) ? bfm.sout1 : bfm.sout0;
                repeat(CLKS_PER_BIT) @(posedge bfm.clk);
            end

            if (frame_phase == 0) begin
                received_address = shift_reg;
                frame_phase = 1;
            end else begin
                received_data = shift_reg;
                frame_phase = 0;
                // Wypełnij pkt zgodnie z definicją uart_packet_t
                // Zakładam, że struktura ma pola adres_frame, data_frame i port
                // — jeśli nazwy/struktury są inne, dostosuj poniżej.
                pkt = '{default: '0}; // zainicjuj wszystkie pola (SystemVerilog aggregate literal)
                pkt.adres_frame.data_bits = received_address;
                pkt.adres_frame.start_bit  = 1'b0; // opcjonalne, ustaw jeśli masz takie pola
                pkt.adres_frame.parity_bit = 1'b0; // opcjonalne
                pkt.adres_frame.stop_bit   = 1'b1; // opcjonalne

                pkt.data_frame.data_bits   = received_data;
                pkt.data_frame.start_bit   = 1'b0; // opcjonalne
                pkt.data_frame.parity_bit  = 1'b0; // opcjonalne
                pkt.data_frame.stop_bit    = 1'b1; // opcjonalne

                pkt.port = current_port;

                // Wyślij pakiet do scoreboardu (ten typ scoreboard oczekuje)
                result_monitor_h.write_to_monitor(pkt);
            end

            prev_sout0 = bfm.sout0;
            prev_sout1 = bfm.sout1;

            // // Obsługa resetu DUT (jeśli potrzebna)
            // if (!bfm.rst_n) begin
            //     cmd.op = rst_op;
            //     reset_ap.write(cmd);
            // end
        end
    end

    task automatic send_uart_frame(

        // input uart_frame_t frame, 
        input uart_packet_t packet,
        input operation_t op,
        input bit force_parity_error = 0
    );

        command_s command;
        uart_frame_t adres;
        uart_frame_t data;
        bit parity_bit_to_send;

        command.op = op;
        command.packet = packet;
        command_monitor_h.write_to_monitor(command);

        packet.adres_frame = adres;
        packet.data_frame = data;

        $display("Sending UART frame...");
        
        sin = adres.start_bit;
        repeat (CLKS_PER_BIT) @(posedge clk);

        for (int i = 0; i < 8; i++) begin
            sin = adres.data_bits[i];
            repeat (CLKS_PER_BIT) @(posedge clk);
        end

        if (force_parity_error)
            parity_bit_to_send = ~adres.parity_bit;
        else
            parity_bit_to_send = adres.parity_bit;

        sin = parity_bit_to_send;
        repeat (CLKS_PER_BIT) @(posedge clk);

        sin = adres.stop_bit;
        repeat (CLKS_PER_BIT) @(posedge clk);

        // data send 
        sin = data.start_bit;
        repeat (CLKS_PER_BIT) @(posedge clk);

        for (int i = 0; i < 8; i++) begin
            sin = data.data_bits[i];
            repeat (CLKS_PER_BIT) @(posedge clk);
        end

        if (force_parity_error)
            parity_bit_to_send = ~data.parity_bit;
        else
            parity_bit_to_send = data.parity_bit;

        sin = parity_bit_to_send;
        repeat (CLKS_PER_BIT) @(posedge clk);

        sin = data.stop_bit;
        repeat (CLKS_PER_BIT) @(posedge clk);


    endtask

//------------------------------------------------------------------------------
// write command monitor
//------------------------------------------------------------------------------

    task automatic reset();
    begin
        rst_n = 0;
        $display("Applying reset...");
        repeat (10) @(posedge clk); 
        // -> ev_reset_test_start;
        rst_n = 1;
        repeat (5) @(posedge clk);   

        // reset_scoreboard();
    end
    endtask

    // function operation_t op2enum();
    //     operation_t opi;
    //     if( ! $cast(opi,sin) )
    //         $fatal(1, "Illegal operation on op bus");
    //     return opi;
    // endfunction : op2enum

    

endinterface : switch_bfm