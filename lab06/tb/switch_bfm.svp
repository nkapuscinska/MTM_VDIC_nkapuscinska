interface switch_bfm;
import fifomult_tb_pkg::*; 
   
logic clk;
logic rst_n;
logic prog;
bit sin;
logic sout0;
logic sout1;




// event ev_reset_test_start;
// event ev_bad_parity_test_start;
// event ev_end_of_test;

operation_t op_set;


command_monitor command_monitor_h;
result_monitor result_monitor_h; 

// uart_packet_t packet_q[$];
// uart_packet_t coverage_packet_q[$];
// uart_observed_t expected_data_q[$];
// uart_observed_t observed_q[$];


    initial begin : clk_gen_blk
        clk = 0;
        forever begin : clk_frv_blk
            #10;
            clk = ~clk;
        end
    end

    initial begin
        prog = 1;
    end

    task automatic send_uart_frame(
        // input uart_frame_t frame, 
        input uart_packet_t packet,
        input operation_t op,
        input bit force_parity_error = 0
    );
        command_s command;
        uart_frame_t adres;
        uart_frame_t data;
        bit parity_bit_to_send;

        command.op = op;
        command.packet = packet;
        command_monitor_h.write_to_monitor(command);

        packet.adres_frame = adres;
        packet.data_frame = data;
        
        
        // $display("Sending UART frame: start=%b data=%b parity=%b stop=%b",
        //     frame.start_bit, frame.data_bits, frame.parity_bit, frame.stop_bit);

        // adress send
        sin = adres.start_bit;
        repeat (CLKS_PER_BIT) @(posedge clk);

        for (int i = 0; i < 8; i++) begin
            sin = adres.data_bits[i];
            repeat (CLKS_PER_BIT) @(posedge clk);
        end

        if (force_parity_error)
            parity_bit_to_send = ~adres.parity_bit;
        else
            parity_bit_to_send = adres.parity_bit;

        sin = parity_bit_to_send;
        repeat (CLKS_PER_BIT) @(posedge clk);

        sin = adres.stop_bit;
        repeat (CLKS_PER_BIT) @(posedge clk);

        // data send 
        sin = data.start_bit;
        repeat (CLKS_PER_BIT) @(posedge clk);

        for (int i = 0; i < 8; i++) begin
            sin = data.data_bits[i];
            repeat (CLKS_PER_BIT) @(posedge clk);
        end

        if (force_parity_error)
            parity_bit_to_send = ~data.parity_bit;
        else
            parity_bit_to_send = data.parity_bit;

        sin = parity_bit_to_send;
        repeat (CLKS_PER_BIT) @(posedge clk);

        sin = data.stop_bit;
        repeat (CLKS_PER_BIT) @(posedge clk);


    endtask

//------------------------------------------------------------------------------
// write command monitor
//------------------------------------------------------------------------------

    task automatic reset();
    begin
        rst_n = 0;
        $display("Applying reset...");
        repeat (10) @(posedge clk); 
        // -> ev_reset_test_start;
        rst_n = 1;
        repeat (5) @(posedge clk);   

        // reset_scoreboard();
    end
    endtask

    // function operation_t op2enum();
    //     operation_t opi;
    //     if( ! $cast(opi,sin) )
    //         $fatal(1, "Illegal operation on op bus");
    //     return opi;
    // endfunction : op2enum

endinterface : switch_bfm